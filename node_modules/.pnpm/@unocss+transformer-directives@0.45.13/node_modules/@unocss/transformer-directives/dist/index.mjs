import { cssIdRE, expandVariantGroup, notNull, regexScopePlaceholder } from '@unocss/core';
import { parse, walk, generate, clone } from 'css-tree';

function transformerDirectives(options = {}) {
  return {
    name: "css-directive",
    enforce: options?.enforce,
    idFilter: (id) => !!id.match(cssIdRE),
    transform: (code, id, ctx) => {
      return transformDirectives(code, ctx.uno, options, id);
    }
  };
}
const themeFnRE = /theme\((.*?)\)/g;
const screenRuleRE = /(@screen) (.+) /g;
async function transformDirectives(code, uno, options, filename, originalCode, offset) {
  const {
    varStyle = "--at-",
    throwOnMissing = true
  } = options;
  const isApply = code.original.includes("@apply") || varStyle !== false && code.original.includes(varStyle);
  const isScreen = code.original.includes("@screen");
  const hasThemeFn = code.original.match(themeFnRE);
  if (!isApply && !hasThemeFn && !isScreen)
    return;
  const ast = parse(originalCode || code.original, {
    parseAtrulePrelude: false,
    positions: true,
    filename
  });
  if (ast.type !== "StyleSheet")
    return;
  const calcOffset = (pos) => offset ? pos + offset : pos;
  const handleApply = async (node, childNode) => {
    let body;
    if (childNode.type === "Atrule" && childNode.name === "apply" && childNode.prelude && childNode.prelude.type === "Raw") {
      body = childNode.prelude.value.trim();
    } else if (varStyle !== false && childNode.type === "Declaration" && childNode.property === `${varStyle}apply` && childNode.value.type === "Raw") {
      body = childNode.value.value.trim();
      if (body.match(/^(['"]).*\1$/))
        body = body.slice(1, -1);
    }
    if (!body)
      return;
    const classNames = expandVariantGroup(body).split(/\s+/g).map((className) => className.trim().replace(/\\/, ""));
    const utils = (await Promise.all(
      classNames.map((i) => uno.parseToken(i, "-"))
    )).filter(notNull).flat().sort((a, b) => a[0] - b[0]).sort((a, b) => (a[3] ? uno.parentOrders.get(a[3]) ?? 0 : 0) - (b[3] ? uno.parentOrders.get(b[3]) ?? 0 : 0)).reduce((acc, item) => {
      const target = acc.find((i) => i[1] === item[1] && i[3] === item[3]);
      if (target)
        target[2] += item[2];
      else
        acc.push([...item]);
      return acc;
    }, []);
    if (!utils.length)
      return;
    for (const i of utils) {
      const [, _selector, body2, parent] = i;
      const selector = _selector?.replace(regexScopePlaceholder, " ") || _selector;
      if (parent || selector && selector !== ".\\-") {
        let newSelector = generate(node.prelude);
        if (selector && selector !== ".\\-") {
          const selectorAST = parse(selector, {
            context: "selector"
          });
          const prelude = clone(node.prelude);
          prelude.children.forEach((child) => {
            const parentSelectorAst = clone(selectorAST);
            parentSelectorAst.children.forEach((i2) => {
              if (i2.type === "ClassSelector" && i2.name === "\\-")
                Object.assign(i2, clone(child));
            });
            Object.assign(child, parentSelectorAst);
          });
          newSelector = generate(prelude);
        }
        let css = `${newSelector}{${body2}}`;
        if (parent)
          css = `${parent}{${css}}`;
        code.appendLeft(calcOffset(node.loc.end.offset), css);
      } else {
        code.appendRight(calcOffset(childNode.loc.end.offset), body2);
      }
    }
    code.remove(
      calcOffset(childNode.loc.start.offset),
      calcOffset(childNode.loc.end.offset)
    );
  };
  const handleThemeFn = (node) => {
    const value = node.value;
    const offset2 = value.loc.start.offset;
    const str = code.original.slice(offset2, value.loc.end.offset);
    const matches = Array.from(str.matchAll(themeFnRE));
    if (!matches.length)
      return;
    for (const match of matches) {
      const rawArg = match[1].trim();
      if (!rawArg)
        throw new Error("theme() expect exact one argument, but got 0");
      let value2 = uno.config.theme;
      const keys = rawArg.slice(1, -1).split(".");
      keys.every((key) => {
        if (value2[key] != null)
          value2 = value2[key];
        else if (value2[+key] != null)
          value2 = value2[+key];
        else
          return false;
        return true;
      });
      if (typeof value2 === "string") {
        code.overwrite(
          offset2 + match.index,
          offset2 + match.index + match[0].length,
          value2
        );
      } else if (throwOnMissing) {
        throw new Error(`theme of "${rawArg.slice(1, -1)}" did not found`);
      }
    }
  };
  const handleScreen = (node) => {
    let breakpointName = "";
    let prefix;
    if (node.name === "screen" && node.prelude?.type === "Raw")
      breakpointName = node.prelude.value.trim();
    if (!breakpointName)
      return;
    const match = breakpointName.match(/^(?:(lt|at)-)?(\w+)$/);
    if (match) {
      prefix = match[1];
      breakpointName = match[2];
    }
    const resolveBreakpoints = () => {
      let breakpoints;
      if (uno.userConfig && uno.userConfig.theme)
        breakpoints = uno.userConfig.theme.breakpoints;
      if (!breakpoints)
        breakpoints = uno.config.theme.breakpoints;
      return breakpoints;
    };
    const variantEntries = Object.entries(resolveBreakpoints() ?? {}).map(([point, size], idx) => [point, size, idx]);
    const generateMediaQuery = (breakpointName2, prefix2) => {
      const [, size, idx] = variantEntries.find((i) => i[0] === breakpointName2);
      if (prefix2) {
        if (prefix2 === "lt")
          return `@media (max-width: ${calcMaxWidthBySize(size)})`;
        else if (prefix2 === "at")
          return `@media (min-width: ${size})${variantEntries[idx + 1] ? ` and (max-width: ${calcMaxWidthBySize(variantEntries[idx + 1][1])})` : ""}`;
        else
          throw new Error(`breakpoint variant not surpported: ${prefix2}`);
      }
      return `@media (min-width: ${size})`;
    };
    if (!variantEntries.find((i) => i[0] === breakpointName))
      throw new Error(`breakpoint ${breakpointName} not found`);
    const offset2 = node.loc.start.offset;
    const str = code.original.slice(offset2, node.loc.end.offset);
    const matches = Array.from(str.matchAll(screenRuleRE));
    if (!matches.length)
      return;
    for (const match2 of matches) {
      code.overwrite(
        offset2 + match2.index,
        offset2 + match2.index + match2[0].length,
        `${generateMediaQuery(breakpointName, prefix)} `
      );
    }
  };
  const stack = [];
  const processNode = async (node, _item, _list) => {
    if (isScreen && node.type === "Atrule")
      handleScreen(node);
    if (hasThemeFn && node.type === "Declaration")
      handleThemeFn(node);
    if (isApply && node.type === "Rule") {
      await Promise.all(
        node.block.children.map(async (childNode, _childItem) => {
          if (childNode.type === "Raw")
            return transformDirectives(code, uno, options, filename, childNode.value, calcOffset(childNode.loc.start.offset));
          await handleApply(node, childNode);
        }).toArray()
      );
    }
  };
  walk(ast, (...args) => stack.push(processNode(...args)));
  await Promise.all(stack);
}
function calcMaxWidthBySize(size) {
  const value = size.match(/^-?[0-9]+\.?[0-9]*/)?.[0] || "";
  const unit = size.slice(value.length);
  const maxWidth = parseFloat(value) - 0.1;
  return Number.isNaN(maxWidth) ? size : `${maxWidth}${unit}`;
}

export { transformerDirectives as default, transformDirectives };
